---
title: 'How to simulate the Universe on a computer'
date: 2025-02-23
permalink: 
tags:
  - N-body simulations
  - Hydrodynamic simulations
---

Hello there! In this post, I will write a bit about cosmological simulations.
Yes, it's a promise-I've been meaning to do this since I created this blog, and 
it's been a while since my last post. 

Why do people try to simulate our Universe on computers?
---------------------

First things first: we have always been passionate about understanding our Universe, and what better way to do so than by mimicking 
it using the tools we have: **computational power** and **cosmology**?
But why rely on numerical simulations? Well, if you've read a bit about cosmology, you'll know that understanding how matter behaves 
on **small scales** is _quite challenging_. The "simple theory" (linear cosmology) works remarkably well for describing large-scale 
structures (Gaussian fields), but it breaks down at smaller scales, where nonlinearities start to dominate.

![](https://raw.githubusercontent.com/natalidesanti/natalidesanti.github.io/refs/heads/master/images/linearXnon_linear.png)
###### Figure 1: [Linear and nonlinear power spectrum comparison. The spectra are presented for redshift zero. The impact of nonlinearities is evident starting from $k \gtrsim 0.1$ h/Mpc.](https://raw.githubusercontent.com/natalidesanti/natalidesanti.github.io/6fabcde9346842c8effc5f6ff0f94205695ada05/images/Screenshot%20from%202022-01-25%2017-20-24.png)

For example, in the case of the **power spectrum** - a summary statistic that describes how much matter (or power) exists at different 
scales ($k$) - we can use linear theory to model the distribution of matter up to $k \lesssim 0.1$ h/Mpc. 
Beyond this point, the power spectrum becomes nonlinear. See Figure 1.

To predict clustering on small scales, the _main approach_ is through **numerical simulations**. 
These simulations employ high-resolution, multi-scale schemes and are routinely used on
massively parallel computers to increase their size and complexity, aiming to better describe the
Universe. 
Given the complexity of the Universe and its various components, these numerical
solutions can be classified into two main categories: **$N$-body** (or DM-only) **simulations** and
**hydrodynamical** (or DM plus baryons) **simulations**. 
$N$-body simulations involve solely DM, with gravity being the only force acting on the particles. 
On the other hand, hydrodynamical simulations incorporate both DM and baryonic matter (e.g., gas), 
allowing for the inclusion of phenomena such as feedback from supernova explosions and supermassive 
black holes (BH), magnetic effects, and more. 
Let's discuss a bit more about both sets of simulations.

N-body simulations
---------------------------

$N$-body (or DM-only) simulations are numerical solutions of a very high number ($N$)
of DM particles interacting gravitationally within a finite volume, and evolving over a long
period of time (or a large range of redshifts). 
Essentially, they provide an alternative path to solutions of the collisionless Boltzmann 
equations coupled with Poissonâ€™s equation.
Examples of such simulations include the [Millennium](https://wwwmpa.mpa-garching.mpg.de/galform/virgo/millennium/), 
[Dark Sky](https://darksky.slac.stanford.edu), and [Bolshoi](https://hipacc.ucsc.edu/Bolshoi.html) simulations, 
which are widely used by the scientific community to study large-scale structures and the behavior of DM on large volumes. 
Another notable example is the [Quijote project](https://quijote-simulations.readthedocs.io/en/latest/), which consists of a 
collection of $43,100$ full $N$-body simulations designed to provide an extensive data set of cosmological simulations for 
machine learning (ML) applications. 

In this post I will present one of the techniques employed to solve the problem of simulating cosmological structures: 
the **particle mesh** (PM) algorithm. 
Other methods, such as _particle-particle schemes_ or _hybrid schemes_, also exist, each with its own advantages and
disadvantages.

The PM method is a relatively simple approach that I used myself when first delving into cosmology. 
I coded my own version of the method, largely following the principles outlined an amazing collection of 
[notes](https://astro.uchicago.edu/~andrey/talks/PM/pm_slides.pdf) from Dr. Andrey Kravtsov. 
PM codes utilize a mesh to represent density and potential fields, with the resolution of the simulation 
limited by the size of this mesh. 
Despite its simplicity, the PM method offers several advantages. 
It is fast, requiring fewer operations per particle per time step, compared to other methods. 
Additionally, PM simulations can handle very large numbers of particles efficiently.

Numerical N-body algorithms allow the study of nonlinear gravitational evolution of complex particle systems. 
These simulations model the time evolution of a given system by determining and tracking the trajectories of particles, 
taking into account their mutual gravitational interactions. Thus, a PM code solves both the **Poisson equation**
\begin{equation}
 \nabla^2 \Phi = 4 \pi G \, \Omega_{m, 0} \, \rho_{crit} \, a^{- 1} \delta \, ,\label{eq:poisson}
\end{equation}
as well as the equations of motion of the particles,
\begin{align}
  \frac{d \mathbf{x}}{d a} & = \frac{\mathbf{p}}{\dot{a} \, a^2} \label{eq:xa} \\
  \frac{d \mathbf{p}}{d a} & = - \frac{\mathbf{\nabla} \Phi}{\dot{a}} \, . \label{eq:pa}
\end{align}

These equations are written in terms of comoving coordinates, i.e., $\mathbf{x} = \mathbf{r}/a$, where 
$\mathbf{r}$ represents the proper particle's fluid position, and $\mathbf{p} = a \mathbf{v} = a^2 \dot{\mathbf{x}}$ 
denotes the particle momenta, where
\begin{equation}
  \mathbf{v} = \mathbf{u} - H \mathbf{r} = a \dot{\mathbf{x}} \label{eq:pec_vel}
\end{equation}
is the peculiar velocity, and $\mathbf{u}$ is the proper velocity (including the Hubble flow).

It is convenient to define code variables, i.e., dimensionless variables, that we will denote with
tildes according to:
\begin{align}
  \tilde{\mathbf{x}} \equiv & \frac{\mathbf{x}}{r_0} = \frac{\mathbf{r}}{a r_0} , \\
  \tilde{\mathbf{p}} \equiv & \frac{\mathbf{p}}{v_0} = \frac{a \mathbf{v}}{v_0} , \\
  \tilde{\Phi} & \equiv \frac{\Phi}{\phi_0} , \\
  \tilde{\rho} & \equiv a^3 \frac{\rho}{\rho_0} .
\end{align}  
The quantities with subscript zero correspond to physical variables responsible for removing the units from the code 
variables and are defined as
\begin{align}
  r_0 & \equiv \frac{L_{BOX}}{N_g} ,\\
  t_0 & \equiv \frac{r_0}{t_0} , \\
  \rho_0 & \equiv \rho_{crit} \Omega_{m, 0} , \\
  \Phi_0 & \equiv \frac{r_0^2}{t_0^2} = v_0^2 ,
\end{align}
where $L_{BOX}$ is the box size, measured in Mpc$/h$, $N_g$ is the number of grid cells in each
direction, and $N_g^T = N_g^3$ is the total number of grid cells.
In dimensionless variables, we can re-write the equations as
\begin{align}
 \tilde{\nabla}^2 \tilde{\Phi} & = \frac{3}{2} \frac{\Omega_{m, 0}}{a} \tilde{\delta} , \label{eq:Tpoisson} \\
 \frac{d \tilde{\mathbf{x}}}{d a} & = f (a) \frac{ \tilde{ \mathbf{p} } }{a^2} , \label{eq:Txa}\\
 \frac{d \tilde{\mathbf{p}}}{d a} & = - f (a) \tilde{\mathbf{\nabla}} \tilde{\Phi} \label{eq:Tpa},
\end{align}
where $\tilde{\delta} = \tilde{\rho} - 1$ and $f (a) \equiv H_0/\dot{a}$.

The main idea of the PM code is to solve these equations in three main steps:
\begin{enumerate}
 \item Solve the **Poisson Equation** using the density field, estimated with current
 particle positions;
 \item Advance momenta $\tilde{\mathbf{p}}$, using the potential computed in the first step;
 \item Update particle positions $\tilde{\mathbf{x}}$, using the advanced momenta. 
\end{enumerate}  

### Implementation stage: solving the equations

The PM method exploits the fact that the _Poisson equation_ for gravitational potential can be found in real space by 
convolving the density contrast with the Green's function
\begin{equation}
 \tilde{\phi} (\tilde{\mathbf{x}}) = \int d^3 \tilde{x}' ~ G (\tilde{\mathbf{x}} - \tilde{\mathbf{x}}') ~ \tilde{\delta} (\tilde{\mathbf{x}}') .
\end{equation}  
The choice of the particular Green's function $G$ is driven by the fact that we use periodic boundary conditions (PBC).
In Fourier space, the convolution is then replaced by a simple multiplication:
\begin{equation}
 \tilde{\phi} (\tilde{\mathbf{x}}) = G (\mathbf{k}) ~ \tilde{\delta} (\mathbf{k}) . \label{eq:phikGdeltak}
\end{equation}
To obtain the density contrast $\tilde{\delta} (\mathbf{k})$ in Fourier space, first it is necessary to obtain 
$\tilde{\delta} (\tilde{\mathbf{x}})$ in real space, which arises from the density in real space 
$\tilde{\rho} (\tilde{\mathbf{x}})$.

### The density field

In PM algorithms, particles are assumed to have a certain size, mass, shape, and internal density.
This determines the interpolation scheme used to assign densities to grid cells.
A common choice is the **Cloud In Cell** (CIC) method, where particles are represented as cubes (in $3$D) 
of uniform density and of one grid cell size.

The algorithm described above is relatively computationally cheap, accurate, and is commonly used in PM codes.
In this method, the shape function of a particle in $1$ dimension is defined as
\begin{equation}
  S (\tilde{x}) = \frac{1}{\Delta \tilde{x}} \left\{\begin{array}{cc}
    1 , & |\tilde{x}| < \Delta \tilde{x}/2\\
    0, & \textnormal{otherwise}
\end{array}\right. ,
\end{equation}
for a cell size of $\Delta \tilde{x}$.           
Then, the mass fraction of particle at $\tilde{x}_p$, assigned to a cell at $\tilde{x}_{i j k}$, is the
shape function averaged over this cell:
\begin{equation}
 W (\tilde{x}_p - \tilde{x}_{i j k}) = \int^{\tilde{x}_{i j k} + \Delta \tilde{x}/2}_{\tilde{x}_{i j k} - \Delta \tilde{x}/2} d \tilde{x}' ~ S (\tilde{x}_p - \tilde{x}') .
\end{equation}
In $3$ dimensions this process generalizes to
\begin{equation}
  W (\tilde{\mathbf{x}}_p - \tilde{\mathbf{x}}_{i j k}) = W (\tilde{x}_p - \tilde{x}_{i j k}) ~ W (\tilde{y}_p - \tilde{y}_{i j k}) ~ W (\tilde{z}_p - \tilde{z}_{i j k}) \, ,
\end{equation}
such that the density $\tilde{\rho}_{i j k}$ in the corresponding cell is given by
\begin{equation}
  \tilde{\rho}_{i j k} = \sum^{N_p}_{p = 1} \tilde{m}_p W (\tilde{\mathbf{x}}_p - \tilde{\mathbf{x}}_{i j k}) ,
\end{equation}  
where $N_p^T = N_p^3$ is the total number of particles, $N_p$ is the number of particles
"on each direction", and $m_p$ is the particle mass.
In practice, this is achieved by looping over particles and assigning their density to neighboring cells, 
rather than summing over all particles for each cell individually.

### The density contrast field and its Fourier transform

With the grid densities $\tilde{\rho}_{i, j, k} (\tilde{\mathbf{x}})$ on hand, the next step is to obtain
the grid density contrasts $\tilde{\delta}_{i, j, k} (\tilde{\mathbf{x}})$ and convert them to Fourier space.
This transformation is typically accomplished using FFT algorithms, which efficiently compute the
discrete Fourier Transform and its inverse.
By applying the FFT to the grid density contrasts, we obtain the them in Fourier space, denoted as
$\tilde{\delta}_{i, j, k} (\tilde{\mathbf{k}})$.

### The gravitational potential

Now we only need the Green function to obtain the gravitational field $\tilde{\Phi} (\mathbf{k})$.
The Green function is given by
\begin{equation}
   G (\mathbf{k}) = - \frac{3 \Omega_{m, 0}}{8 a} \left[ \sin^2 \left(\frac{k_x}{2}\right) +
    \sin^2\left(\frac{k_y}{2}\right) + \sin^2\left(\frac{k_z}{2}\right) \right]^{- 1} , \label{eq:G(k)}
\end{equation}
where
\begin{equation}
  k_x = \frac{2 \pi l}{L_{BOX}} , \hspace{0.2cm} k_y = \frac{2 \pi m}{L_{BOX}}, \\
  k_z = \frac{2 \pi n}{L_{BOX}}, \hspace{0.2cm} \textnormal{for the components } (l, m, n) . \label{eq:kkk}
\end{equation}
These equations are in code units, hence $L_{BOX} = N_g$.
Then, the gravitational potential is solved by transforming the result back to real space to obtain
$\tilde{\Phi} (\tilde{\mathbf{x}})$ discretized at cell centers.
Note that, when using these gravitational potentials, there is an artifact, a singularity at $l = m = n = 0$, 
which is avoided by setting $\tilde{\Phi}_{0 0 0} = 0$.

### The acceleration

After obtaining the gravitational field in real space $\tilde{\Phi} (\tilde{\mathbf{x}})$, discretized at
cell centers, it is time to obtain the acceleration at each grid point.
This is simply given by
\begin{equation}
 \tilde{\mathbf{a}} (\tilde{\mathbf{x_i}}) = - \tilde{\mathbf{\nabla}} \tilde{\Phi} (\tilde{\mathbf{x_i}}) \, .
\end{equation}  
This step precedes the updating of the particles' positions and momenta, because it requires the
accelerations at each particle's position.
Thus, to obtain the accelerations at the particle positions $\tilde{\mathbf{g}}^p$, we interpolate the
acceleration at grid points $\tilde{\mathbf{a}} (\tilde{\mathbf{x_i}})$ onto the particle positions
$\tilde{\mathbf{x}}_j^p$,
using the CIC interpolation.
During the density assignment, for a given particle, the acceleration at each point is interpolated from the cells 
to which the particle contributed to the density.

### Updating particles positions and momenta

We arrive now at the final stage of the PM method: updating particle positions and momenta.
This is achieved using **leapfrog integration**, which is a numerical
method for integrating differential equations in a dynamical system.
Leapfrog integration updates positions and velocities (or momenta) at interleaved time points 
(or scale factor points), staggered in such a way that they "leapfrog" over each other.

Thus, using the leapfrog integration, we have updated momenta and positions as
\begin{align}
 \tilde{\mathbf{p}}_{n + 1/2} & = \tilde{\mathbf{p}}_{n - 1/2} + f (a_n) \tilde{\mathbf{g}}_n \Delta a \\
 \tilde{\mathbf{x}}_{n + 1} & = \tilde{\mathbf{p}}_{n} + a^{- 2}_{n + 1/2} f (a_{n + 1/2}) \tilde{\mathbf{p}}_{n + 1/2} \Delta a , 
\end{align}  
where $n$ represents the "time" step, $f (a_n)$ is computed at $a_n$, $\Delta a$ is the step in the
scalar factor,
\begin{equation}
 a_n = a_i + n \Delta a 
\end{equation}  
is the evolution in the scale factor according to the "time" steps, and
$a_{n + 1/2} = a_n + \Delta a/2$.
In the present case, we always update the momentum first, in a half time step before update the
positions.

Therefore, the **Particle Mesh** (PM) method involves repeating a series of steps for each time step of the simulation.
The main scheme of the PM method typically consists of the following three blocks, which are repeated iteratively:
\begin{enumerate}
 \item **Find density on the mesh using the Cloud-In-Cell (CIC) technique.**
 This step involves assigning the density of particles to grid cells using the CIC interpolation scheme. 
 \item **Solve the Poisson equation using two 3-dimensional Fast Fourier Transforms (FFTs).**
 After obtaining the density distribution on the mesh, the Poisson equation is solved in Fourier space
 using FFTs to calculate the gravitational potential.
 \item **Advance momenta and positions of the particles.**
 Finally, the momenta and positions of the particles are updated using leapfrog integration based on the calculated gravitational potential. 
\end{enumerate}  
These blocks are repeated for each time step of the simulation to evolve the system over time.

The simulations were conducted using the following **cosmological parameters**:
$H_0 = 73.0$ km s$^{-1}$ Mpc$^{-1}$, $\Omega_{m} = 0.311051$, and $\Omega_{\Lambda} = 0.68887$.
I ran four simulations, which explains the error bars seen in the final products, as I present later on.
I simulated a box of side $L_{BOX} = 128 ~ \text{Mpc}/h$, with $128^3$ particles and $256^3$ cells.
The simulations started from $a = 0.02$ or $z = 49$, up to $a = 1.0$ or $z = 0$.
The ICs were set using the **Multi Scale Initial Conditions**
(\href{https://www-n.oca.eu/ohahn/MUSIC/}{\textsc{MUSIC}}) code \cite{MUSIC}.
To define the initial spectra using `MUSIC` we utilized [CAMB](https://camb.info/).

![Animation of my N-body simulation through time](https://www.youtube.com/watch?v=tvmHQhhf6HI&t=1s)










